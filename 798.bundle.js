(self.webpackChunkaleo_website=self.webpackChunkaleo_website||[]).push([[798],{3798:(e,r,t)=>{t.a(e,(async(e,i)=>{try{t.d(r,{AleoKeyProvider:()=>d,AleoKeyProviderParams:()=>u,PrivateKey:()=>o._q,ProgramManager:()=>y,ProgramManagerBase:()=>o.L,initThreadPool:()=>o.CK,verifyFunctionExecution:()=>o.hz});var o=t(2063),a=e([o]);o=(a.then?(await a)():a)[0];async function n(e){const r=await fetch(e);if(!r.ok)throw new Error(r.status+" could not get URL "+e);return r}async function s(e,r){r.method="POST";const t=await fetch(e,r);if(!t.ok)throw new Error(t.status+" could not post URL "+e);return t}class h{host;account;constructor(e){this.host=e+"/testnet3"}setAccount(e){this.account=e}getAccount(){return this.account}setHost(e){this.host=e+"/testnet3"}async fetchData(e="/"){try{const r=await n(this.host+e);return await r.json()}catch(e){throw new Error("Error fetching data.")}}async findUnspentRecords(e,r,t,i,a,n){if(n=n||[],e<0)throw new Error("Start height must be greater than or equal to 0");const s=new Array;let c,f,l,h,u=0,d=BigInt(0);if(void 0===t){if(void 0===this.account)throw new Error("Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient");l=this.account._privateKey}else try{l=t instanceof o._q?t:o._q.from_string(t)}catch(e){throw new Error("Error parsing private key provided.")}const y=l.to_view_key();try{const e=await this.getLatestHeight();if("number"!=typeof e)throw new Error("Error fetching latest block height.");h=e}catch(e){throw new Error("Error fetching latest block height.")}if(f="number"==typeof r&&r<=h?r:h,e>f)throw new Error("Start height must be less than or equal to end height.");for(;f>e;){c=f-50,c<e&&(c=e);try{const e=await this.getBlockRange(c,f);if(f=c,!(e instanceof Error))for(let r=0;r<e.length;r++){const t=e[r].transactions;if(void 0!==t)for(let e=0;e<t.length;e++){const r=t[e];if("execute"==r.type){const e=r.transaction;if(e.execution&&void 0!==e.execution.transitions)for(let r=0;r<e.execution.transitions.length;r++){const t=e.execution.transitions[r];if("credits.aleo"===t.program&&void 0!==t.outputs)for(let e=0;e<t.outputs.length;e++){const r=t.outputs[e];if("record"===r.type)try{const e=o.fW.fromString(r.value);if(e.isOwner(y)){const r=e.decrypt(y),t=r.nonce();if(n.includes(t))continue;const o=r.serialNumberString(l,"credits.aleo","credits");try{await this.getTransitionId(o)}catch(e){if(!i&&(s.push(r),"number"==typeof a&&(d+=r.microcredits(),d>=BigInt(a))))return s;if(void 0!==i&&i.length>0){let e=0;if(r.microcredits()>i[e]){if(e+=1,s.push(r),"number"==typeof a&&(d+=r.microcredits(),d>=BigInt(a)))return s;if(s.length>=i.length)return s}}}}}catch(e){}}}}}}}catch(e){if(console.warn("Error fetching blocks in range: "+c.toString()+"-"+f.toString()),console.warn("Error: ",e),u+=1,u>10)return console.warn("10 failures fetching records reached. Returning records fetched so far"),s}}return s}async getBlock(e){try{return await this.fetchData("/block/"+e)}catch(e){throw new Error("Error fetching block.")}}async getBlockRange(e,r){try{return await this.fetchData("/blocks?start="+e+"&end="+r)}catch(t){throw new Error("Error fetching blocks between "+e+" and "+r+".")}}async getDeploymentTransactionIDForProgram(e){e instanceof o.$r&&(e=e.toString());try{return(await this.fetchData("/find/transactionID/deployment/"+e)).replace('"',"")}catch(e){throw new Error("Error fetching deployment transaction for program.")}}async getDeploymentTransactionForProgram(e){try{const r=await this.getDeploymentTransactionIDForProgram(e);return await this.getTransaction(r)}catch(e){throw new Error("Error fetching deployment transaction for program.")}}async getLatestBlock(){try{return await this.fetchData("/latest/block")}catch(e){throw new Error("Error fetching latest block.")}}async getLatestCommittee(){try{return await this.fetchData("/committee/latest")}catch(e){throw new Error("Error fetching latest block.")}}async getLatestHeight(){try{return await this.fetchData("/latest/height")}catch(e){throw new Error("Error fetching latest height.")}}async getProgram(e){try{return await this.fetchData("/program/"+e)}catch(e){throw new Error("Error fetching program")}}async getProgramObject(e){try{return o.$r.fromString(e)}catch(r){try{return o.$r.fromString(await this.getProgram(e))}catch(r){throw new Error(`${e} is neither a program name or a valid program`)}}}async getProgramImports(e){try{const r={},t=(e instanceof o.$r?e:await this.getProgramObject(e)).getImports();for(let e=0;e<t.length;e++){const i=t[e];if(!r.hasOwnProperty(i)){const e=await this.getProgram(i),t=await this.getProgramImports(i);for(const e in t)r.hasOwnProperty(e)||(r[e]=t[e]);r[i]=e}}return r}catch(e){throw l("Error fetching program imports: "+e)}}async getProgramImportNames(e){try{return(e instanceof o.$r?e:await this.getProgramObject(e)).getImports()}catch(e){throw new Error("Error fetching program imports with error: "+e)}}async getProgramMappingNames(e){try{return await this.fetchData("/program/"+e+"/mappings")}catch(e){throw new Error("Error fetching program mappings - ensure the program exists on chain before trying again")}}async getProgramMappingValue(e,r,t){try{return await this.fetchData("/program/"+e+"/mapping/"+r+"/"+t)}catch(e){throw new Error("Error fetching mapping value - ensure the mapping exists and the key is correct")}}async getStateRoot(){try{return await this.fetchData("/latest/stateRoot")}catch(e){throw new Error("Error fetching Aleo state root")}}async getTransaction(e){try{return await this.fetchData("/transaction/"+e)}catch(e){throw new Error("Error fetching transaction.")}}async getTransactions(e){try{return await this.fetchData("/block/"+e.toString()+"/transactions")}catch(e){throw new Error("Error fetching transactions.")}}async getTransactionsInMempool(){try{return await this.fetchData("/memoryPool/transactions")}catch(e){throw new Error("Error fetching transactions from mempool.")}}async getTransitionId(e){try{return await this.fetchData("/find/transitionID/"+e)}catch(e){throw new Error("Error fetching transition ID.")}}async submitTransaction(e){const r=e instanceof o.YW?e.toString():e;try{const e=await s(this.host+"/transaction/broadcast",{body:r,headers:{"Content-Type":"application/json"}});try{return await e.json()}catch(e){throw new Error(`Error posting transaction. Aleo network response: ${e.message}`)}}catch(e){throw new Error(`Error posting transaction: No response received: ${e.message}`)}}}class u{proverUri;verifierUri;cacheKey;constructor(e){this.proverUri=e.proverUri,this.verifierUri=e.verifierUri,this.cacheKey=e.cacheKey}}class d{cache;cacheOption;keyUris;async fetchBytes(e="/"){try{const r=await n(e),t=await r.arrayBuffer();return new Uint8Array(t)}catch(e){throw new Error("Error fetching data."+e)}}constructor(){this.keyUris=v,this.cache=new Map,this.cacheOption=!1}useCache(e){this.cacheOption=e}clearCache(){this.cache.clear()}cacheKeys(e,r){const[t,i]=r;this.cache.set(e,[t.toBytes(),i.toBytes()])}containsKeys(e){return this.cache.has(e)}deleteKeys(e){return this.cache.delete(e)}getKeys(e){if(console.debug(`Checking if key exists in cache. KeyId: ${e}`),this.cache.has(e)){const[r,t]=this.cache.get(e);return[o.zW.fromBytes(r),o.XV.fromBytes(t)]}return new Error("Key not found in cache.")}async functionKeys(e){if(e){let r,t,i;if("proverUri"in e&&"string"==typeof e.proverUri&&(r=e.proverUri),"verifierUri"in e&&"string"==typeof e.verifierUri&&(t=e.verifierUri),"cacheKey"in e&&"string"==typeof e.cacheKey&&(i=e.cacheKey),r&&t)return await this.fetchKeys(r,t,i);if(i)return this.getKeys(i)}throw Error("Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl")}async fetchKeys(e,r,t){try{if(this.cacheOption){t||(t=e);const i=this.cache.get(t);if(void 0!==i)return[o.zW.fromBytes(i[0]),o.XV.fromBytes(i[1])];{console.debug("Fetching proving keys from url "+e);const i=o.zW.fromBytes(await this.fetchBytes(e));console.debug("Fetching verifying keys "+r);const a=await this.getVerifyingKey(r);return this.cache.set(t,[i.toBytes(),a.toBytes()]),[i,a]}}{const t=o.zW.fromBytes(await this.fetchBytes(e));return[t,await this.getVerifyingKey(r)]}}catch(t){throw new Error(`Error: ${t} fetching fee proving and verifying keys from ${e} and ${r}.`)}}bondPublicKeys(){return this.fetchKeys(p.bond_public.prover,p.bond_public.verifier,p.bond_public.locator)}claimUnbondPublicKeys(){return this.fetchKeys(p.claim_unbond_public.prover,p.claim_unbond_public.verifier,p.claim_unbond_public.locator)}async transferKeys(e){if(w.has(e))return await this.fetchKeys(p.transfer_private.prover,p.transfer_private.verifier,p.transfer_private.locator);if(_.has(e))return await this.fetchKeys(p.transfer_private_to_public.prover,p.transfer_private_to_public.verifier,p.transfer_private_to_public.locator);if(m.has(e))return await this.fetchKeys(p.transfer_public.prover,p.transfer_public.verifier,p.transfer_public.locator);if(P.has(e))return await this.fetchKeys(p.transfer_public_to_private.prover,p.transfer_public_to_private.verifier,p.transfer_public_to_private.locator);throw new Error("Invalid visibility type")}async joinKeys(){return await this.fetchKeys(p.join.prover,p.join.verifier,p.join.locator)}async splitKeys(){return await this.fetchKeys(p.split.prover,p.split.verifier,p.split.locator)}async feePrivateKeys(){return await this.fetchKeys(p.fee_private.prover,p.fee_private.verifier,p.fee_private.locator)}async feePublicKeys(){return await this.fetchKeys(p.fee_public.prover,p.fee_public.verifier,p.fee_public.locator)}async getVerifyingKey(e){switch(e){case p.bond_public.verifier:return p.bond_public.verifyingKey();case p.claim_unbond_public.verifier:return p.claim_unbond_public.verifyingKey();case p.fee_private.verifier:return p.fee_private.verifyingKey();case p.fee_public.verifier:return p.fee_public.verifyingKey();case p.inclusion.verifier:return p.inclusion.verifyingKey();case p.join.verifier:return p.join.verifyingKey();case p.set_validator_state.verifier:return p.set_validator_state.verifyingKey();case p.split.verifier:return p.split.verifyingKey();case p.transfer_private.verifier:return p.transfer_private.verifyingKey();case p.transfer_private_to_public.verifier:return p.transfer_private_to_public.verifyingKey();case p.transfer_public.verifier:return p.transfer_public.verifyingKey();case p.transfer_public_to_private.verifier:return p.transfer_public_to_private.verifyingKey();case p.unbond_delegator_as_validator.verifier:return p.unbond_delegator_as_validator.verifyingKey();case p.unbond_public.verifier:return p.unbond_public.verifyingKey();default:try{const r=await n(e),t=await r.text();return o.XV.fromString(t)}catch(r){try{return o.XV.fromBytes(await this.fetchBytes(e))}catch(e){return new Error("Invalid verifying key. Error: "+e)}}}}unBondPublicKeys(){return this.fetchKeys(p.unbond_public.prover,p.unbond_public.verifier,p.unbond_public.locator)}}class y{account;keyProvider;host;networkClient;recordProvider;constructor(e,r,t){e?(this.host=e,this.networkClient=new h(e)):(this.host="https://api.explorer.aleo.org/v1",this.networkClient=new h(this.host)),this.keyProvider=r||new d,this.recordProvider=t}setAccount(e){this.account=e}setKeyProvider(e){this.keyProvider=e}setHost(e){this.host=e,this.networkClient.setHost(e)}setRecordProvider(e){this.recordProvider=e}async deploy(e,r,t,i,a,n){try{const r=o.$r.fromString(e);let t;try{t=await this.networkClient.getProgram(r.id())}catch(e){console.log(`Program ${r.id()} does not exist on the network, deploying...`)}if("string"==typeof t)throw`Program ${r.id()} already exists on the network, please rename your program`}catch(e){throw l(`Error validating program: ${e}`)}let s,c=n;if(void 0===n&&void 0!==this.account&&(c=this.account.privateKey()),void 0===c)throw"No private key provided and no private key set in the ProgramManager";try{a=t?await this.getCreditsRecord(r,[],a,i):void 0}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{s=t?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys()}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[f,h]=s;let u;try{u=await this.networkClient.getProgramImports(e)}catch(e){throw l(`Error finding program imports. Network response: '${e}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`)}const d=await o.L.buildDeploymentTransaction(c,e,r,a,this.host,u,f,h);return await this.networkClient.submitTransaction(d)}async buildExecutionTransaction(e,r,t,i,a,n,s,c,f,h,u,d,y,v){if(void 0===y)try{y=await this.networkClient.getProgram(e)}catch(r){throw l(`Error finding ${e}. Network response: '${r}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`)}else y instanceof o.$r&&(y=y.toString());let p,g=u;if(void 0===u&&void 0!==this.account&&(g=this.account.privateKey()),void 0===g)throw"No private key provided and no private key set in the ProgramManager";try{c=i?await this.getCreditsRecord(t,[],c,n):void 0}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{p=i?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys()}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[b,w]=p;if(!f||!h)try{[f,h]=await this.keyProvider.functionKeys(s)}catch(e){console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`)}if(o.$r.fromString(y).getImports().length>0&&!v)try{v=await this.networkClient.getProgramImports(e)}catch(e){throw l(`Error finding program imports. Network response: '${e}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`)}return await o.L.buildExecutionTransaction(g,y,r,a,t,c,this.host,v,f,h,b,w,d)}async execute(e,r,t,i,o,a,n,s,c,f,l,h,u){const d=await this.buildExecutionTransaction(e,r,t,i,o,a,n,s,c,f,l,h,u);return await this.networkClient.submitTransaction(d)}async run(e,r,t,i,a,n,s,c,f,l){let h=f;if(void 0===f&&void 0!==this.account&&(h=this.account.privateKey()),void 0===h)throw"No private key provided and no private key set in the ProgramManager";if(!s||!c)try{[s,c]=await this.keyProvider.functionKeys(n)}catch(e){console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`)}return console.log("Running program offline"),console.log("Proving key: ",s),console.log("Verifying key: ",c),o.L.executeFunctionOffline(h,e,r,t,i,!1,a,s,c,this.host,l)}async join(e,r,t,i,a,n,s,c){let f,h,u=s;if(void 0===s&&void 0!==this.account&&(u=this.account.privateKey()),void 0===u)throw"No private key provided and no private key set in the ProgramManager";try{f=i?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys(),h=await this.keyProvider.joinKeys()}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[d,y]=f,[v,p]=h;try{n=i?await this.getCreditsRecord(t,[],n,a):void 0}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{e=e instanceof o.PD?e:o.PD.fromString(e),r=r instanceof o.PD?r:o.PD.fromString(r)}catch(e){throw l("Records provided are not valid. Please ensure they are valid plaintext records.")}const g=await o.L.buildJoinTransaction(u,e,r,t,n,this.host,v,p,d,y,c);return await this.networkClient.submitTransaction(g)}async split(e,r,t,i){let a,n=t;if(void 0===n&&void 0!==this.account&&(n=this.account.privateKey()),void 0===n)throw"No private key provided and no private key set in the ProgramManager";try{a=await this.keyProvider.splitKeys()}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[s,c]=a;try{r=r instanceof o.PD?r:o.PD.fromString(r)}catch(e){throw l("Record provided is not valid. Please ensure it is a valid plaintext record.")}const f=await o.L.buildSplitTransaction(n,e,r,this.host,s,c,i);return await this.networkClient.submitTransaction(f)}async synthesizeKeys(e,r,t,i){let a,n=i;void 0===n&&(n=void 0!==this.account?this.account.privateKey():new o._q);try{a=await this.networkClient.getProgramImports(e);const i=await o.L.synthesizeKeyPair(n,e,r,t,a);return[i.provingKey(),i.verifyingKey()]}catch(e){throw l(`Could not synthesize keys - error ${e}. Please ensure the program is valid and the inputs are correct.`)}}async buildTransferTransaction(e,r,t,i,a,n,s,h,u,d){t=f(t);let y,v,p=u;if(void 0===p&&void 0!==this.account&&(p=this.account.privateKey()),void 0===p)throw"No private key provided and no private key set in the ProgramManager";try{y=a?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys(),v=await this.keyProvider.transferKeys(t)}catch(e){throw l(`Error finding fee keys. Key finder response: '${e}'. Please ensure your key provider is configured correctly.`)}const[g,b]=y,[w,_]=v;try{const e=[];c(t)?(s=await this.getCreditsRecord(i,[],s,n),e.push(s.nonce())):s=void 0,h=a?await this.getCreditsRecord(i,e,h,n):void 0}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}return await o.L.buildTransferTransaction(p,e,r,t,s,i,h,this.host,w,_,g,b,d)}async buildTransferPublicTransaction(e,r,t,i,o){return this.buildTransferTransaction(e,r,"public",t,!1,void 0,void 0,void 0,i,o)}async transfer(e,r,t,i,o,a,n,s,c,f){const l=await this.buildTransferTransaction(e,r,t,i,o,a,n,s,c,f);return await this.networkClient.submitTransaction(l)}async buildBondPublicTransaction(e,r,t={}){r=Math.trunc(1e6*r);const{offlineParams:i={},executionParams:o={}}=t||{};let{programName:a="credits.aleo",functionName:n="bond_public",fee:s=o?.fee||.86,privateFee:c=!1,recordSearchParams:f,keySearchParams:l,feeRecord:h,provingKey:d,verifyingKey:y,privateKey:v}=o;void 0===l&&(l=new u({proverUri:p.bond_public.prover,verifierUri:p.bond_public.verifier,cacheKey:"credits.aleo/bond_public"}));const{offlineQuery:g}=i;return await this.buildExecutionTransaction(a,n,s,c,[e,`${r.toString()}u64`],f,l,h,d,y,v,g,this.creditsProgram())}async bondPublic(e,r,t={}){const i=await this.buildBondPublicTransaction(e,r,t);return await this.networkClient.submitTransaction(i)}async buildUnbondPublicTransaction(e,r={}){e=Math.trunc(1e6*e);const{offlineParams:t={},executionParams:i={}}=r||{};let{programName:o="credits.aleo",functionName:a="unbond_public",fee:n=i?.fee||1.3,privateFee:s=!1,recordSearchParams:c,keySearchParams:f,feeRecord:l,provingKey:h,verifyingKey:d,privateKey:y}=i;void 0===f&&(f=new u({proverUri:p.unbond_public.prover,verifierUri:p.unbond_public.verifier,cacheKey:"credits.aleo/unbond_public"}));const{offlineQuery:v}=t;return this.buildExecutionTransaction(o,a,n,s,[`${e.toString()}u64`],c,f,l,h,d,y,v,this.creditsProgram())}async unbondPublic(e,r={}){const t=await this.buildUnbondPublicTransaction(e,r);return await this.networkClient.submitTransaction(t)}async buildClaimUnbondPublicTransaction(e={}){const{offlineParams:r={},executionParams:t={}}=e||{};let{programName:i="credits.aleo",functionName:o="claim_unbond_public",fee:a=t?.fee||2,privateFee:n=!1,recordSearchParams:s,keySearchParams:c,feeRecord:f,provingKey:l,verifyingKey:h,privateKey:d}=t;void 0===c&&(c=new u({proverUri:p.claim_unbond_public.prover,verifierUri:p.claim_unbond_public.verifier,cacheKey:"credits.aleo/claim_unbond_public"}));const{offlineQuery:y}=r;return await this.buildExecutionTransaction(i,o,a,n,[],s,c,f,l,h,d,y,this.creditsProgram())}async claimUnbondPublic(e={}){const r=await this.buildClaimUnbondPublicTransaction(e);return await this.networkClient.submitTransaction(r)}async setValidatorState(e,r={}){const{offlineParams:t={},executionParams:i={}}=r||{};let{programName:o="credits.aleo",functionName:a="set_validator_state",fee:n=1,privateFee:s=!1,recordSearchParams:c,keySearchParams:f,feeRecord:l,provingKey:h,verifyingKey:d,privateKey:y}=i;void 0===f&&(f=new u({proverUri:p.set_validator_state.prover,verifierUri:p.set_validator_state.verifier,cacheKey:"credits.aleo/set_validator_state"}));const{offlineQuery:v}=t;return await this.execute(o,a,n,s,[e.toString()],c,f,l,h,d,y,v)}async unbondDelegatorAsValidator(e,r={}){const{offlineParams:t={},executionParams:i={}}=r||{};let{programName:o="credits.aleo",functionName:a="unbond_delegator_as_validator",fee:n=1,privateFee:s=!1,recordSearchParams:c,keySearchParams:f,feeRecord:l,provingKey:h,verifyingKey:d,privateKey:y}=i;void 0===f&&(f=new u({proverUri:p.unbond_delegator_as_validator.prover,verifierUri:p.unbond_delegator_as_validator.verifier,cacheKey:"credits.aleo/unbond_delegator_as_validator"}));const{offlineQuery:v}=t;return await this.execute(o,a,n,s,[e],c,f,l,h,d,y,v)}verifyExecution(e){try{const r=e.getExecution(),t=e.getFunctionId(),i=e.getProgram(),a=e.getVerifyingKey();return(0,o.hz)(r,a,i,t)}catch(e){return console.warn("The execution was not found in the response, cannot verify the execution"),!1}}createProgramFromSource(e){return o.$r.fromString(e)}creditsProgram(){return o.$r.getCreditsProgram()}verifyProgram(e){try{return o.$r.fromString(e),!0}catch(e){return!1}}async getCreditsRecord(e,r,t,i){try{return t instanceof o.PD?t:o.PD.fromString(t)}catch(t){try{const t=this.recordProvider;return await t.findCreditsRecord(e,!0,r,i)}catch(e){throw l(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}}}}function c(e){return g.has(e)}function f(e){return b.has(e)?e:l(`Invalid transfer type '${e}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`)}const v="https://testnet3.parameters.aleo.org/",p={bond_public:{locator:"credits.aleo/bond_public",prover:v+"bond_public.prover.9c3547d",verifier:"bond_public.verifier.10315ae",verifyingKey:o.XV.bondPublicVerifier},claim_unbond_public:{locator:"credits.aleo/claim_unbond_public",prover:v+"claim_unbond_public.prover.f8b64aa",verifier:"claim_unbond_public.verifier.8fd7445",verifyingKey:o.XV.claimUnbondPublicVerifier},fee_private:{locator:"credits.aleo/fee_private",prover:v+"fee_private.prover.43fab98",verifier:"fee_private.verifier.f3dfefc",verifyingKey:o.XV.feePrivateVerifier},fee_public:{locator:"credits.aleo/fee_public",prover:v+"fee_public.prover.634f153",verifier:"fee_public.verifier.09eeb4f",verifyingKey:o.XV.feePublicVerifier},inclusion:{locator:"inclusion",prover:v+"inclusion.prover.cd85cc5",verifier:"inclusion.verifier.e6f3add",verifyingKey:o.XV.inclusionVerifier},join:{locator:"credits.aleo/join",prover:v+"join.prover.1a76fe8",verifier:"join.verifier.4f1701b",verifyingKey:o.XV.joinVerifier},set_validator_state:{locator:"credits.aleo/set_validator_state",prover:v+"set_validator_state.prover.5ce19be",verifier:"set_validator_state.verifier.730d95b",verifyingKey:o.XV.setValidatorStateVerifier},split:{locator:"credits.aleo/split",prover:v+"split.prover.e6d12b9",verifier:"split.verifier.2f9733d",verifyingKey:o.XV.splitVerifier},transfer_private:{locator:"credits.aleo/transfer_private",prover:v+"transfer_private.prover.2b487c0",verifier:"transfer_private.verifier.3a3cbba",verifyingKey:o.XV.transferPrivateVerifier},transfer_private_to_public:{locator:"credits.aleo/transfer_private_to_public",prover:v+"transfer_private_to_public.prover.1ff64cb",verifier:"transfer_private_to_public.verifier.d5b60de",verifyingKey:o.XV.transferPrivateToPublicVerifier},transfer_public:{locator:"credits.aleo/transfer_public",prover:v+"transfer_public.prover.a74565e",verifier:"transfer_public.verifier.a4c2906",verifyingKey:o.XV.transferPublicVerifier},transfer_public_to_private:{locator:"credits.aleo/transfer_public_to_private",prover:v+"transfer_public_to_private.prover.1bcddf9",verifier:"transfer_public_to_private.verifier.b094554",verifyingKey:o.XV.transferPublicToPrivateVerifier},unbond_delegator_as_validator:{locator:"credits.aleo/unbond_delegator_as_validator",prover:v+"unbond_delegator_as_validator.prover.115a86b",verifier:"unbond_delegator_as_validator.verifier.9585609",verifyingKey:o.XV.unbondDelegatorAsValidatorVerifier},unbond_public:{locator:"credits.aleo/unbond_public",prover:v+"unbond_public.prover.9547c05",verifier:"unbond_public.verifier.09873cd",verifyingKey:o.XV.unbondPublicVerifier}},g=new Set(["transfer_private","private","transferPrivate","transfer_private_to_public","privateToPublic","transferPrivateToPublic"]),b=new Set(["transfer_private","private","transferPrivate","transfer_private_to_public","privateToPublic","transferPrivateToPublic","transfer_public","public","transferPublic","transfer_public_to_private","publicToPrivate","transferPublicToPrivate"]),w=new Set(["private","transfer_private","transferPrivate"]),_=new Set(["private_to_public","privateToPublic","transfer_private_to_public","transferPrivateToPublic"]),m=new Set(["public","transfer_public","transferPublic"]),P=new Set(["public_to_private","publicToPrivate","transfer_public_to_private","transferPublicToPrivate"]);function l(e){throw console.error(e),e}i()}catch(K){i(K)}}))}}]);
//# sourceMappingURL=798.bundle.js.map